# Forgather Projects

This is an absolutely minimalist exmpale project, which defines and constructs a simple list, which will be used to illustrate the structure of a Forgather project.

A project in Forgather is defined simply by placing a file named "meta.yaml" in a directory. This file is the project's meta-configuration, which describes where to find configurations within the project and where to search for includable templates.

A project directory may also (optional) include a 'README.md' and/or a project index ('project_index.ipynb') file.

This project has both. If you are directly reading the README.md, the file you really want is the index, which includes this file.

The project index can by dynamically regenerated by running the first cell in the notebook and has the following sections:

### Project Directory

This shows the absolute path of the project, which can be useful for opening the project with the notebooks linked at the top of this notebook.

### Meta Config

This includes a link to the meta-config file (meta.yaml). Clicking on the link will open this file.

This is followed by a template include graph of the meta-config file. This example does not include any other templates, so there is only a single file listed.

Project configurations are can be constructe from Jinja2 templates and the meta-config lists all of the directories which will be searched for templates. This is a simple project, which is entirely self-contained, but most projects will include multiple search paths here.

### Available Configurations

The meta-config defines where in the template namespace top-level configuration files may be found. This section lists all configurations within this namespace.

This also shows which configuration is the default and which is presently selected. The active template can be specified by filling out the "config_template" argument to nb.display_project_index().

### Available Templates

This lists the names of all available configuration templates within the template searchpath.

### Included Templates

Starting with the active configuration, each configuration template is recursively parsed to identity all sub-templates which are directly and indirectly included in the present configuration. This will normally be a sub-set of "Available Templates."

### Modules

This list all dynamically imported modules in the project. This project does not use dynamic imports, so the list is empty.

### Preprocessed Config

All configuration templates use a combination of Jinja2 and YAML syntax. This section shows what the resulting configuration file looks like after being processed by Jinja.

### Loaded Configuration

After the configuration has been proprocessed and parsed into a graph, the generated graph is translated back into YAML for verification. While this may be identical to the input for trivial configurations, more complex configurations may be refactored and rendered differently than the input.

### Generated Source Code

A loaded configuration graph can be exported as Python code, which is exactly what this section shows.

The output can itself use a template for formatting, but the project index uses the default code template, which defines a function named 'construct' which return the defined configuration when called.

### Constructed Project

The configuration is constructed as a Python object and dumped via pprint.pformat() in this section, with Python syntax highlighting.

The constructed object is to created from the generated code, but from interpreting the configuration graph. In theory, the running the code will generate exactly the same output.

### Extra Credit

Change the selected configuration to the 'other' available configuration in this project and regnerate the project index.

```python
nb.display_project_index(config_template="poems.yaml", materialize=True, pp_first=False)
```

---
